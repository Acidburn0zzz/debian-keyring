#!/usr/bin/python3

# Authors: Daniel Kahn Gillmor <dkg@fifthhorseman.net>,
#          Gunnar Wolf <gwolf@debian.org>,
#          Jonathan McDowell <noodles@earth.li>
# License: Parts from dkg are GPLv3+

import os
from os import path
import socket
from subprocess import run, Popen, PIPE
from shutil import copy, rmtree
from distutils.dir_util import copy_tree
import sys
import tempfile
import hashlib
import codecs
from multiprocessing.pool import ThreadPool
from typing import List


def check_environ(should_run_on: str = 'kaufmann.debian.org') -> None:
    if not (os.environ.get('RUNANYWAY', False) or
            socket.getfqdn(socket.gethostname()) == should_run_on):
        raise Exception('''
This script is meant to be run in %s
You can still run it if you are sure by setting
$RUNANYWAY to a nonempty value.
        ''' % (should_run_on))


def wkd_localpart(incoming: bytes) -> str:
    'see https://tools.ietf.org/html/draft-koch-openpgp-webkey-service-08#section-3.1'

    # https://tools.ietf.org/html/rfc6189#section-5.1.6
    zb32 = "ybndrfg8ejkmcpqxot1uwisza345h769"

    b = hashlib.sha1(incoming).digest()
    ret = ""
    assert(len(b) * 8 == 160)
    for i in range(0, 160, 5):
        byte = i // 8
        offset = i - byte * 8
        # offset | bits remaining in k+1 | right-shift k+1
        # 3 | 0 | x
        # 4 | 1 | 7
        # 5 | 2 | 6
        # 6 | 3 | 5
        # 7 | 4 | 4
        if offset < 4:
            n = (b[byte] >> (3 - offset))
        else:
            n = (b[byte] << (offset - 3)) + (b[byte + 1] >> (11 - offset))

        ret += zb32[n & 0b11111]
    return ret


def getdomainlocalpart(line: bytes, domain: bytes) -> bytes:
    if line.startswith(b'uid:'):
        uid = line.split(b':')[9]
        if uid.endswith(b'@' + domain + b'>'):
            broken = uid.split(b'<')
            if len(broken) != 2:
                raise ValueError("unexpected User ID %s" % (uid))
            return broken[1][:-len(b'@' + domain + b'>')].lower()
    return None


def gpgbase(keyrings: List[str]) -> List[str]:
    return ['gpg', '--batch', '--no-options', '--with-colons',
            '--no-default-keyring',
            '--homedir=/dev/null', '--trust-model=always',
            '--fixed-list-mode'] + list(map(lambda k: '--keyring=' + k, keyrings))


def emit_wkd(localpart: bytes, domain: str, keyrings: List[str]) -> None:
    wkdstr = wkd_localpart(localpart)
    # what do we do if this local part is not a proper encoding?
    addr = codecs.decode(localpart) + '@' + domain
    cmd = gpgbase(keyrings) + ['--output',
                               path.join('openpgpkey', domain, 'hu', wkdstr),
                               '--export-options',
                               'export-clean',
                               '--export-filter',
                               'keep-uid=mbox=' + addr,
                               '--export',
                               '<' + addr + '>']
    run(cmd, check=True)


def build_wkd(domain: str, keyrings: List[str]):
    if not path.isdir('openpgpkey'):
        os.mkdir('openpgpkey')
    os.mkdir(path.join('openpgpkey', domain))
    os.mkdir(path.join('openpgpkey', domain, 'hu'))

    # FIXME: deal with IDN:
    bytedomain = codecs.encode(domain)

    lister = Popen(gpgbase(keyrings) +
                   ['--list-keys', '@' + domain], stdout=PIPE)

    localparts = set(
        map(lambda x: getdomainlocalpart(x, bytedomain), lister.stdout))
    localparts.discard(None)

    def runner(x):
        return emit_wkd(x, domain, keyrings)

    pool = ThreadPool(None)
    for localpart in localparts:
        pool.apply_async(runner, (localpart,))

    pool.close()
    pool.join()
    # make the policy file:
    policyfile = open(path.join('openpgpkey', domain, 'policy'), 'wb')
    del policyfile


def publish(srcdir: str,
            prefix: str = None) -> None:
    if prefix is None:
        prefix = os.environ.get('PREFIX', '/srv/keyring.debian.org')
    pendingdir = path.join(prefix, 'pending-updates')
    hkpdir = path.join(prefix, 'keyrings-new')
    outputdir = path.join(prefix, 'pub')
    for direc in [srcdir, pendingdir, hkpdir, outputdir]:
        if not path.isdir(direc):
            raise Exception("%s is not a directory" % (direc))
    srcdir = path.realpath(srcdir)
    sha512fname = path.join(srcdir, 'sha512sums.txt')
    if not path.exists(sha512fname):
        raise Exception('sha512sums.txt not found in %s' % (srcdir))
    placeholder = path.join(srcdir, 'keyrings', '.placeholder')
    if path.exists(placeholder):
        os.unlink(placeholder)
    # gpgv needs the keyring in the filesystem, not just a file
    # descriptor (https://dev.gnupg.org/T4608)
    with tempfile.NamedTemporaryFile() as maint_keyring:
        maint_keyring.write(keyring_maint_keys())
        gpgvcall = [
            'gpgv',
            '--enable-special-filenames',
            '--keyring',
            maint_keyring.name,
            '--output',
            '-',
            sha512fname]
        gpgvout = run(gpgvcall, stderr=PIPE, stdout=PIPE)
        if gpgvout.returncode != 0:
            raise Exception("gpg verification failed:\n%s" %
                            (codecs.decode(gpgvout.stderr)))
    os.chdir(srcdir)
    files_to_check = set(
        path.join('keyrings', x + '.gpg') for x in [
            'debian-keyring',
            'debian-maintainers',
            'debian-nonupload',
            'debian-role-keys',
            'emeritus-keyring'])
    unexpected_files = set()
    for line in filter(lambda x: x, codecs.decode(gpgvout.stdout).split('\n')):
        (indigest, fname) = line.split()
        with open(fname, 'rb') as f:
            data = f.read()
        digest = hashlib.new('sha512', data=data).hexdigest()
        if digest != indigest:
            raise Exception(
                'mismatched digest for %s.\nWanted: %s\nGot: %s' %
                (fname, indigest, digest))
        if fname in files_to_check:
            files_to_check.remove(fname)
        else:
            unexpected_files.add(fname)
    if files_to_check:
        raise Exception('No sha512 digest found for: %s' % (files_to_check))
    if unexpected_files:
        print(
            'unexpected files (maybe add them to files_to_check):',
            unexpected_files)

    keyrings = ['keyring', 'maintainers', 'nonupload']
    for kname in keyrings:
        kfile = path.join(pendingdir, 'debian-%s.gpg' % (kname))
        if path.exists(kfile):
            raise Exception(
                'Unhandled pending updates.\nKeyrings in %s should be dealt with and removed' %
                (pendingdir))

    for kname in keyrings:
        kfile = path.join(hkpdir, 'debian-%s.gpg' % (kname))
        copy(kfile, pendingdir)

    print('Updating active keyrings.')
    copy_tree(srcdir, outputdir)
    print('Updating HKP keyrings.')
    for kname in keyrings:
        kfile = path.join(srcdir, 'keyrings', 'debian-%s.gpg' % (kname))
        copy(kfile, hkpdir)
    print('Publishing WKD data (may take a few minutes).')
    with tempfile.TemporaryDirectory(prefix='wkd_staging_', dir=prefix) as wkd_staging:
        os.chdir(wkd_staging)

        def dkeyring(name: str):
            return path.join(srcdir, 'keyrings', 'debian-' + name + '.gpg')
        build_wkd('debian.org',
                  [dkeyring(x) for x in [
                      'nonupload',
                      'keyring',
                      'role-keys']])
        wkd_deploy_path = path.join(prefix, 'openpgpkey')
        # not quite an atomic move:
        if path.isdir(wkd_deploy_path):
            os.rename(wkd_deploy_path, 'openpgpkey.old')
        os.rename('openpgpkey', wkd_deploy_path)
        os.chdir(srcdir)
    run(['static-update-component', 'openpgpkey.debian.org'], check=True)


def keyring_maint_keys() -> bytes:
    '''Extract keyring-maint keys from the local system keyrings.

On DSA-managed hosts, /srv/keyring.debian.org/keyrings is more recent
and up-to-date so we prefer it.  On other hosts that have the
debian-keyring package installed, we can fall back to it.
    '''
    keyring_locations = [
        '/srv/keyring.debian.org/keyrings',
        '/usr/share/keyrings']
    keyrings = ['debian-keyring.gpg', 'debian-nonupload.gpg']
    keyring_maint_uids = ['Jonathan McDowell <noodles@earth.li>',
                          'William John Sullivan <johns@debian.org>',
                          'Gunnar Eyal Wolf Iszaevich <gwolf@debian.org>',
                          'Daniel Kahn Gillmor <dkg@debian.org>']
    keyring_files = None
    for loc in keyring_locations:
        possible_keyrings = [path.join(loc, k) for k in keyrings]
        if path.isdir(loc) and all(
                map(lambda k: path.exists(k), possible_keyrings)):
            keyring_files = possible_keyrings
            break

    if keyring_files is None:
        raise Exception(
            "Could not find keyrings to extract keyring-maint keys")

    gpgcmd = ['gpg',
              '--batch',
              '--homedir',
              '/dev/null',
              '--no-options',
              '--no-default-keyring',
              '--export-options',
              'export-minimal']
    for k in keyring_files:
        gpgcmd += ['--keyring', k]
    gpgcmd += ['--export']
    gpgcmd += ['=' + u for u in keyring_maint_uids]

    return run(gpgcmd, stdout=PIPE, check=True).stdout


if __name__ == '__main__':
    if len(sys.argv) < 2:
        raise Exception('Must provide directory containing new keyrings.')
    elif len(sys.argv) > 2:
        sys.argv.pop(0)
        subcommand = sys.argv.pop(0)
        if subcommand != 'build-wkd':
            raise Exception("do not know this subcommand: %s" % (subcommand))
        if len(sys.argv):
            domain = sys.argv.pop(0)
        else:
            domain = 'debian.org'
        if len(sys.argv):
            keys = sys.argv
        else:
            keys = ['/usr/share/keyrings/debian-nonupload.gpg',
                    '/usr/share/keyrings/debian-keyring.gpg',
                    '/usr/share/keyrings/debian-role-keys.gpg']
        build_wkd(domain, keys)
    else:
        # standard update-keyrings
        check_environ()
        publish(sys.argv[1])
